
#include <stdio.h>

/*
 * Nested for loop optimization
 */
#define NROWS 128
#define NCOLS 128

#define CACHE_LINE_SIZE 128
/*
 * The division does not need to be converted because the size of an integer 
 * is a multiple of 2.
 */
#define SM ( CACHE_LINE_SIZE / sizeof(int) )

int ia[NROWS][NCOLS];

/*
 * 1 - declare INDUCTION VARIABLES outside the for loop.
 * 2 - since `ia` is a statically allocated GLOBAL array, it means that every 
 *   time the memory page associated to the variable must be loaded.
 * 3 - split the problem into subproblems to increase cache locality.
 * 4 - unroll the inner loop; try to reduce the number of iterations (i.e., 
 *   the number of times the condition is evaluated).
 * 5 - try to increased parallelism with software pipelining.
 */

void _loop_rowise() {
	/*
	 * By looking at the assembly code generated by the compiler the code 
	 * looks FULL OF BUBBLES.
	 *
	 * Since the conditions follow a well predictable behavior the processor 
	 * may still execute with a good degree of efficiency this code.
	 *
	 * Need to be tested.
	 */

	/*
	 * THIS APPROACH has a HUGE disadvantage: that it only works when NROWS 
	 * and NCOLS are multiple of SM, otherwise the conter exceed the array's 
	 * size.
	 */
	int *rowptr;
	int row, col, row2, col2;
	for(row = 0; row < NROWS; row+=SM){
		for(col = 0; col < NCOLS; col+=SM){
			/*
			 * DISADVANTAGE: load the memory address of `ia` every time in the 
			 * loop!
			 */
			for(row2 = 0, rowptr = &ia[row][col]; row2 < SM; ++row2, rowptr+=NCOLS){
				for(col2 = 0; col2 < SM; ++col2){
					rowptr[col2] = 1;
				}
			}
		}
	}
}

void _loop_colwise() {
	int i, j;
	for(j = 0; j < NCOLS; j++) {
		for(i = 0; i < NROWS; i++) {
			ia[j][i] = 1;
		}
	}
}



int main(int argc, char **argv) {
	_loop_rowise();

	/*int *ptr = &ia[0][0];
	for(int i = 0; i < NROWS; i++) {
		printf("ia[%d][...] = ", i);
		for(int j = 0; j < NCOLS; j++) {
			printf("%d ", *(ptr+i+j));
		}
		printf("\n");
	}*/
	return 0;
}